---
title: 为何是 Tanstack Start
description: 为何是 Tanstack Start，而不是 Next.js
---
Next.js 无疑是优秀的框架，VibeAny 最初也基于 Next.js 构建。但随着项目演进和技术生态变化，我们最终选择重构至 TanStack Start。这不是对 Next.js 的否定，而是基于实际开发痛点的深思熟虑的技术决策。

---

## 1. **终结"黑盒魔法"：拥抱显式与可控**

Next.js 的核心哲学是"约定优于配置"，但近年来逐渐演变成了"隐式魔法"的困境：
- **缓存策略的反复横跳**：从 Next.js 15 到 16，缓存策略从"默认缓存"切换到"默认不缓存"，再引入复杂的 `use cache` 指令。开发者常常发现自己不仅在与代码作斗争，还在与框架不透明的行为作斗争。
- **调试黑洞**：当页面未按预期刷新时，你很难判断问题出在路由缓存、数据缓存还是组件缓存。

**TanStack Start 的选择：显式优于隐式**
- 数据加载（Loaders）、缓存配置和中间件都在代码中**显式定义**，而非隐藏在框架内部。
- 正如社区开发者所言："它是无聊的（褒义）——简单的路由、清晰的数据加载、没有隐藏的魔法。"
- **结果**：更少的意外行为，更短的调试时间，更高的可维护性。

---

## 2. **真正的类型安全：不仅仅是"支持 TypeScript"**

在 2026 年，全栈类型安全的标准已从"支持 TypeScript"进化为**端到端类型保障**（从 URL 到数据库）。

**Next.js 的局限**：
- 类型安全在边界处容易断裂（如搜索参数 `searchParams`、服务器操作 `Server Actions`）。
- `typedRoutes` 仍是实验性功能，且需要手动类型断言来弥补缺失。

**TanStack Start 的优势**：
- 基于 **TanStack Router**，提供业界领先的类型安全路由系统。
- **100% 类型推断**：路由参数、搜索参数、Loader 返回数据全链路类型校验。
- **编译时捕获错误**：链接拼写错误或参数类型不匹配会在 `tsc` 编译时报错，而非运行时崩溃。

**示例对比**：
```tsx
// Next.js：类型容易丢失
const params = await searchParams; // 类型: any
const id = params.id; // 需要手动验证

// TanStack Start：完全类型推断
const { id } = Route.useSearch(); // 类型: string (根据 schema 自动推断)
```

---

## 3. **Server Functions vs Server Actions：理念之争**

虽然两者都允许从客户端调用服务器代码,但设计哲学截然不同。

**Next.js Server Actions 的问题**：
- 深度绑定表单场景，作为通用数据获取手段时存在缺陷。
- **默认顺序执行**，无法并行调用多个 Actions。
- 缺乏内置的类型安全输入验证。
- `use server` 指令的隐式行为易引发困惑（如意外暴露 API 端点）。

**TanStack Server Functions 的设计**：
- 更像**类型安全的 RPC**（远程过程调用）。
- 内置 Validator、中间件支持、完整类型推断。
- 调用方式如同普通函数，无需担心序列化边界或类型丢失。

**示例**：
```tsx
// TanStack Start
export const updateUser = createServerFn()
  .validator((data: { name: string; age: number }) => data)
  .handler(async ({ data }) => {
    // data 的类型自动推断为 { name: string; age: number }
    return db.users.update(data);
  });

// 客户端调用（完全类型安全）
await updateUser({ name: 'Alice', age: 30 });
```

---

## 4. **客户端优先 vs 强制 RSC：架构理念的分歧**

**Next.js 的"服务器优先"困境**：
- 默认所有组件为 React Server Components (RSC)。
- 对于高交互性应用（SaaS 工具、仪表盘），需频繁添加 `"use client"`。
- 水合错误（Hydration Errors）、序列化限制等问题带来额外心智负担。

**TanStack Start 的"客户端优先"策略**：
- 默认构建流畅的 SPA 体验，同时支持 SSR 和流式渲染。
- 仅在需要 SEO、数据预加载或隐藏密钥时主动利用服务器能力。
- **更符合开发者直觉**：应用主要在客户端运行，服务器作为增强层而非默认层。

---

## 5. **开发体验：Vite 的极速 vs Turbopack 的追赶**

尽管 Next.js 16 将 Turbopack 设为默认，但 **Vite 仍是 2026 年开发体验的黄金标准**。

**实际痛点对比**：
| 维度 | Next.js + Turbopack | TanStack Start + Vite |
|------|---------------------|----------------------|
| 启动速度 | 大型项目 5-10 秒 | 毫秒级 |
| 内存占用 | 10-12GB（M4 Pro） | 3-5GB |
| HMR 稳定性 | 偶尔卡顿，需重启 | 闪电般即时更新 |
| 生态兼容 | 部分插件需适配 | 庞大的 Vite 插件生态 |

**开发者心流保护**：
- 修改代码后即刻可见，无需等待编译器。
- 减少上下文切换，保持专注状态。

---

## 6. **数据获取与缓存：拥抱经过实战检验的方案**

**Next.js 的缓存争议**：
- 自定义 `fetch` 缓存机制在 v15/16 中引发大量困惑。
- 需要手动配置 `dynamic`、`revalidate` 才能获得预期行为。
- 与现有生态（如 React Query）割裂。

**TanStack Start 的集成方案**：
- 直接集成 **TanStack Query**（原 React Query），基于成熟的 SWR 模式。
- **细粒度控制**：`staleTime`、`gcTime`、乐观更新、无限加载、后台轮询。
- **零学习成本**：对于已熟悉 React Query 的团队，数据流是自然且强大的。

**示例**：
```tsx
// 声明式数据获取，自动处理缓存、重试、加载状态
const { data, isLoading } = useSuspenseQuery({
  queryKey: ['users'],
  queryFn: fetchUsers,
  staleTime: 5 * 60 * 1000, // 5 分钟后数据过期
});
```

---

# 结论：选择适合你的工具

我们的迁移并非"黑" Next.js，而是基于以下现实：
- **显式控制 > 隐式魔法**：在复杂项目中，透明性比便利性更重要。
- **类型安全是刚需**：端到端类型保障显著减少运行时错误。
- **开发体验直接影响生产力**：Vite 的极速反馈让团队保持高效。

**我们的建议**：
- ✅ **继续使用 Next.js**：如果你的团队已熟悉 Next.js 且项目运行良好。
- ✅ **尝试 TanStack Start**：如果你正在启动新的交互密集型项目，或对 Next.js 的隐式行为感到困扰。

技术选型没有银弹，只有最适合当前场景的工具。对我们而言,TanStack Start 提供了更现代、更简洁、更灵活的开发体验。
